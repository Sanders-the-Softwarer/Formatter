-- Просто оператор select
select * from dual

-- select из таблицы с алиасом
select * from dual d

-- select с with
with a as (select * from dual), b as (select * from dual), c as (select * from dual) select * from a, b, c

-- select с несколькими полями
select a, b, c from dual

-- select с алиасами в полях
select a, b b, c as c from dual

-- select с выражениями в полях
select 1, 'abc', 3 + 4 from dual

-- select с выражениями и алиасами
select 1 + 2 a, 'abc' as b, sysdate from dual

-- select c into
select a into b from dual

-- select c bulk collect into
select a bulk collect into b from dual

-- select из нескольких таблиц
select * from a, b, c, d

-- select из табличной функции
select * from table(x)

-- select из подзапроса
select * from (select * from dual)

-- select с lateral
select * from a, lateral(select * from dual) b

-- select с where
select * from dual where dummy = 'Y'

-- select с group by
select * from dual group by dummy, dummy, dummy

-- select с having
select * from dual group by dummy having count(*) > 1

-- select со start with / connect by
select * from dual start with dummy = 'X' connect by prior dummy <> 'Y'

-- select с order by
select * from dual order by dummy

-- указание направления сортировки и расположения null-ов в order by
select * from dual order by dummy desc nulls last, dummy nulls first, dummy asc

-- связывание запросов через операции над множествами
select * from dual union select * from dual minus select * from dual intersect select * from dual union all select * from dual

-- выравнивание полей в select
select 1 a, 222, 3 + 4 + 5 as b, 6 + 7 + 8 c, 9 as d from dual

-- Сопоставление полей в select into
select a, b, c, d, e into x, y, z, t, w from dual

-- select с ansi-синтаксисом
select * from a join b on a.id = b.id

-- select с предложением using
select * from a join b using (id)

-- select с left/right/full join-ами
select * from a left join b on (a.id = b.id) right join c using (id, id, id) full join d on (date_from > sysdate)

-- select с лишними словами в join-ах
select * from a left outer join b on (a.id = b.id) right outer join c using (id, id, id)
full outer join d on (date_from > sysdate) inner join e on (1 = 2)

-- select с оракловым синтаксисом внешних соединений
select * from a, b where a.id (+) = b.id and decode(a.value (+), 1, 2, null, 3, 4) = 2

-- select c outer/cross apply
select * from a cross apply (select * from b) outer apply (select * from c)

-- select может иметь условие distinct, unique или all
select distinct * from (select unique * from (select all * from dual))

-- функция count и подобные также могут содержать distinct/unique/all
select count (distinct *), count (unique *), count (all *) from dual

-- Просто оператор insert
insert into dual values ('Y')

-- insert с алиасом таблицы
insert into dual t values ('Y')

-- insert в подзапрос
insert into (select * from dual) values ('Y')

-- insert в подзапрос с алиасом
insert into (select * from dual) t values ('Y')

-- insert с указанием полей
insert into dual (dummy) values ('Y')

-- insert с сопоставлением полей
insert into t (a, b, c, d, e) values (1, 2, 3, 4, 5)

-- insert/select, тоже с сопоставлением
insert into t (a, b, c, d, e) select 1, 2, 3, 4, 5 from dual

-- insert с returning
insert into values ('Y') returning dummy into new_value

-- insert/returning с сопоставлением
insert into t (a, b, c, d, e) values (1, 2, 3, 4, 5) returning a, b, c, d, e into p_a, p_b, p_c, p_d, p_e

-- просто оператор update
update dual set dummy = 'Y'

-- update с алиасом
update dual d set d.dummy = 'Y'

-- update с подзапросом (и алиасом)
update (select * from dual) d set dummy = 'Y'

-- update с множественными присваиваниями
update t set a = 1, b = 2, c = 3, d = 4, e = 5

-- update с where
update t set a = 1 where b = 2

-- update с returning
update t set a = 1 where b = 2 returning a into p_a

-- update с сопоставлением в returning
update t set a = 1 where b = 2 returning a, b, c, d, e into p_a, p_b, p_c, p_d, p_e

-- просто оператор delete
delete from dual

-- delete с алиасом
delete from dual d

-- delete с where
delete from dual where dummy = 'Y'

-- просто оператор merge
merge into dual d1 using (select * from dual) d2 on (d1.dummy = d2.dummy)
when matched then update set dummy = 'Y' when not matched then insert (dummy) values ('Y')

-- merge с другим порядком выражений
merge into dual d1 using (select * from dual) d2 on (d1.dummy = d2.dummy)
when not matched then insert (dummy) values ('Y') when matched then update set dummy = 'Y'

-- merge с подзапросом
merge into (select * from dual) d1 using (select * from dual) d2 on (d1.dummy = d2.dummy)
when matched then update set dummy = 'Y' when not matched then insert (dummy) values ('Y')

-- вложенный запрос в select
select (select * from dual) from dual

-- вложенный select во from
select * from (select * from dual)

-- вложенный select в where
select * from dual where (select * from dual) = 'Y'

-- команда create
create package x is end;

-- команда create or replace
create or replace package x is end;

-- операнд может быть числом
select 1.666 from dual

-- операнд может иметь префикс + или -
select +1, -2 from dual

-- операнд может быть литералом
select 'a' from dual

-- операнд может быть константой null, true или false
select null from dual where true = false

-- операнд может иметь префикс not
select not null from dual

-- операнд может быть конструкцией case
select case when 1 = 2 then 3 when 4 = 5 then 6 else 7 end, case null when true then 1 else 0 end from dual

-- операнд может быть выражением cast
select cast (1 as number(5, 2)), cast ('222' as char(28 char)), cast (null as packaged.object.tipe) from dual

-- операнд может быть выражением exists
select * from dual where not exists (select * from dual)

-- операнд может быть идентификатором и прочим lvalue
select a, b.c, d.e.f, g.h(i).j from dual

-- в квалифицированных идентификаторах некстати попадаются пробелы
select a + b. c + d .e + f . g + h. i(1). k + l .m(1) .n from dual

-- операнд может иметь суффикс
select a%notfound, b%found, c%rowcount, d%isopen from dual

-- операнд может быть вложенным запросом
select 1 + (select count(*) from dual) from dual

-- операнд может быть выражением в скобках
select (((((3.1415))))) from dual

-- операнд может сочетаться с постфиксными операциями is [not] null
select * from dual where dummy is null and dummy is not null

-- операнд может быть вызовом функции
select to_date('01.02.2004', 'dd.mm.yyyy') + my.fanction(a => b, c => d) from dual

-- выражения состоят из операндов, связанных между собой бинарными операциями
select
  1+2,
  1+-2,
  'a'*4,
  5/0,
  1||b+c
from
  dual
where
  a = 1 and b < 2 and c > 3 and d <= 4 and e >= 5 and f <> 6 and g != 7 and h ^= 8 and i like 9 and j not like 10
  and k in (11, 12, 13) and (l, m, n) not in (select * from dual) or o between 14 and 15

-- выражение может содержать multiset операции во всех комбинациях
select
  a multiset union b,
  a multiset union distinct b,
  a multiset union all b,
  a multiset intersect b,
  a multiset intersect distinct b,
  a multiset intersect all b,
  a multiset except b,
  a multiset except distinct b,
  a multiset except all b
from dual

-- анонимный блок может быть begin .. end и содержать операторы
begin null; end;

-- программный блок может быть declare .. end и содержать переменные и операторы
declare x integer; begin x := 1; end;

-- программный блок может содержать серии переменных и операторов
declare
  x integer;
  y integer;
  procedure z is
  begin
    x := 3;
    y := 4;
  end;
begin
  x := 1;
  y := 2;
  z;
end;

-- программный блок может завершаться слешем
begin
end;
/

-- программный блок может содержать обработчики исключений
begin
  begin
  exception
    raise;
  end;
exception
  when invalid_number then null; raise; return;
  when others or somebody_else then return; null; raise;
end;

-- заголовок пакета
package x is
end;
/

-- тело пакета
package body x is
end;
/

-- подпрограмма может быть процедурой либо функцией

procedure x is begin end;
function y return number is begin end;

-- подпрограмма может иметь параметры

procedure x (a integer, b varchar2, c tablet.tipe, d sys_anydata);

-- функция может обладать признаками pipelined или deterministic

function pi return number deterministic is begin return 3.1415926; end;
function pipelied return tablet.tipe pipelined is begin pipe row (null); end;

-- в объявлении подпрограммы переменные идут после is без declare

procedure x is
  a integer;
  b varchar2(1000);
begin
end;

-- типы могут быть
create or replace package x is
  -- простым идентификатором
  a integer;
  -- определяться через ключевое слово char
  b char;
  -- обладать суффиксом %type или %rowtype
  c schema.tablet%type;
  d schema.tablet.ccolumn%rowtype;
  -- содержать указатель размера
  e number(10);
  -- и точность
  f number(10,2);
  -- либо единицу измерения
  g char(10 char);
  h char(10 byte);
end;

-- параметры подпрограммы могут использовать модификаторы in/out/nocopy

procedure x (a integer, b in char, c in out varchar2, d nocopy tablet.tipe, e in out nocopy super.tablet.tipe);

-- параметры подпрограммы могут иметь значения по умолчанию

function y (a integer, b char := 'a', c date default null);

-- проверка выравнивания в параметрах подпрограмм

procedure x(a char, bb in out varchar2, ccc integer default 12345, dddd out char := big_function_call(1, 2, 3));

-- объявления переменных могут содержать модификатор constant и исходное значение

declare
  a boolean := true;
  b constant number;
  c constant char(1 byte) default 'a';
begin
end;

-- проверка выравнивания в переменных

declare
  a boolean := true;
  bbbb constant number;
  cc constant char(1 byte) default 'a';
begin
end;

-- раздел деклараций может содержать курсоры

declare
  cursor a is select * from dual;
begin
end;

-- курсоры могут быть параметризованы

package x is
  cursor c (a integer, b varchar2 := 'x') is select * from dual;
end;

-- курсоры могут специфицировать тип результата

package x is
  cursor c return dual%rowtype is select * from dual;
end;

-- в блоках деклараций можно объявлять исключения
package x is
  e exception;
  f exception;
  g varchar2;
  h exception;
end;

-- в блоках декларации можно указывать прагмы
declare
  e exception;
  pragma anonymous_transaction;
  pragma exception_init(e, -1024);
begin
end;

-- тип может быть записью
declare
  type t is record (a integer, b char(100 char), c my.tablet.tipe := my.tablet.tipe());
begin
end;

-- тип может быть табличным
declare
  type t is table of varchar2;
  type tt is table of number index by varchar2(64);
begin
end;

-- оператор может быть оператором присваивания

begin
  i := 1;
end;

-- оператор может быть вызовом процедуры
begin
  proc;
  proc(1, 2, 3);
  proc(a => 1, b => 2);
end;

-- проверка выравнивания в вызове процедуры
begin
  proc(a => 1, bb => 22, ccc => 333, d => 4444, ee => 55555);
end;

-- оператор может быть возвратом из подпрограммы
begin
  return;
  return to_date('01.02.2004');
end;

-- оператор может быть null
begin
  null;
end;

-- оператор может быть raise
begin
  raise invalid_number;
  raise;
end;

-- оператор может быть if
begin
  if a = b then null; end if;
  if a = b then null; else raise; end if;
  if a = b then null; elsif c = d then return; elsif e > f then proc; else raise; end if;
end;

-- оператор может быть case
begin
  case when a = b then null; when c > d then raise; else null; end case;
  case a when b then null; when c then raise; else null end case;
end;

-- оператор может быть loop
begin
  loop
    null;
    return;
    raise;
  end loop;
end;

-- оператор может быть for
begin
  for i in 1 .. 10 loop null; end loop;
  for j in reverse 1..10 loop null; end loop;
  for k in (select * from dual) loop null; end loop;
  for l in my_cursor loop null; end loop;
  for m in my_cursor(param1, param2, param3 => value) loop null; end loop;
end;

-- оператор может быть while
begin
  while a > b loop null; end loop;
end;

-- оператор может быть forall
begin
  forall i in 1..10 insert into t values (i);
  forall i in 1..10 save exceptions insert into t values (i);
  forall i in indices of my.tablet(1) save exceptions insert into t values (i);
  forall i in values of your.tablet save exceptions insert into t values (i);
end;

-- оператор может быть pipe row
begin
  pipe row(1, 2, 3, 4, a + b or c, '6');
end;

-- оператор может быть open for
begin
  open c for select * from dual;
end;

-- оператор может быть fetch
begin
  fetch c into a, b, c, d, e;
end;

-- оператор может быть close
begin
  close c;
end;

-- оператор может быть exit
begin
  loop
    exit;
    exit when sql%notfound;
  end loop;
end;

-- оператор может быть execute immediate
begin
  execute immediate 'some expression';
  execute immediate p_str into p_a, p_b, p_c using p_d, p_e, p_f;
end;

-- оператор create view
create or replace force view v$dual as select * from dual

-- create view с запросом, начинающимся с with
create force view v$dual as with x as (select * from dual) select * from x

-- Комментарии, а также проверка выравнивания в комментариях
comment on table v$dual is 'Вьюха';
comment on column v$dual.id is 'Ключ';
comment on column v$dual.name is 'Название';

--------------------------------------------------------------------------------------------

-- недопустимость выражений вместо полей в insert
-- insert into t (a, 2, c) values (1, b, 3)

-- недопустимость выражений вместо полей в update
-- update t set 1 = 2

-- недопустимость выражений вместо полей в returning
-- update t set a = b returning '1', '2', '3' into ('4' + '5'), 6, 7

